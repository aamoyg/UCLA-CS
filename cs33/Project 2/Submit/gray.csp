; UCLA Spring	2003
; CS 33 Project 2
; Roberto Javier Vega
; SID: 003-110-717
; April, 12 2003
;
; GRAY-CODE ENCODER
;
; Uses CUSP mini_os.obj routines.
;
	.EQU	@, $000 ; START PROGRAM AT POSSITION $000
;
; MINI OS CONSTANTS
	.EQU	PUT_NUM,  $E00
	.EQU	GET_NUM,  $E01
	.EQU	PUT_STR,  $E05
	.EQU	PUT_NL,   $E06
	.EQU	PUT_NUM2, $E07
;
; PROGRAM CONSTANTS
	.EQU	LO, 2
	.EQU	HI, 20
	.EQU	MAXBITS, 24
	.EQU	HEXMAX, $FFFFFF
;	
; EXECUTION STARTS
	LDS#	$E00				; INITIALIZE STACK POINTER
;
; PRT PROGRAM GREATTING
	PSH#    PRTPRG_LEN			; OTORE LENGTH OF GREATING STRING INTO STACK
	PSH#    PRT_PRG				; OTORE GREATING INTO STACK
	JSR     PUT_STR				; OUTPUT STRING TO CRT
	JSR     PUT_NL				; OUTPUT NEW LINE
	JSR     PUT_NL				; OUTPUT NEW LINE
;
; RESET VARIABLES				; CLEAR VARIABLES
	LDA		N_NEG_ONE
	STA		N_WIDTH			; N_WIDTH = -1
 	LDA#		0					
 	STA		N_VALUE			; N_VALUE = 0
 	STA		N_CODED			; N_CODED = 0
	STA		N_HOLD			; N_HOLD  = 0
	STA		N_PARTS			; N_PARTS = 0
	STA		N_USED			; N_USED  = 0
	STA		DATA			; DATA    = 0
;
; START PROGRAM MAIN 
MAIN_LOOP:
	LDA		N_WIDTH			; N_WIDTH ? 
	CMA#		0
	JLT     	GET_WIDTH		; N_WIDTH < 0 JUMP TO GET NEW WIDTH
	JGT		INS_CODE		; N_WIDTH > 0 JUMP TO INSERT VALUE ENTERED INTO DATA
	JEQ		PRINT_WORD_EXIT		; N_WIDTH = 0 JUMP TO CHECK IF THERE IS A WORD LEFT
								; IF SO, CODE IT AND OUTPUT IT, THEN HALT
; GET WIDTH FROM THE USER, IF VALID STORE IT ON N_WIDTH
GET_WIDTH:
	PSH#	PRT_WIDTH_LEN		; OUTPUT WIDHT:
	PSH#	PRT_WIDTH			;
	JSR	PUT_STR				;
	JSR	GET_NUM				; STORE NUMBER INTO N_WIDTH
	STA	N_WIDTH				;
	CMA#	0				; IF N_WIDHT = 0
	JEQ	PRINT_WORD_EXIT			; PRINT THE WORD (IF NEEDED) AND EXIT
	CMA#	LO				; IF N_WIDTH < LO
	JLT	INV_WIDTH			; OUTPUT INVALID WIDTH AND GET WIDTH AGAIN
	CMA#	HI				; IF N_WIDTH > HI
	JGT	INV_WIDTH			; OUTPUT INVALID WIDTH AND GET WIDTH AGAIN
	JMP	GET_VALUE			; IF WIDHT IS VALID GET THE VALUE
; PRINT INVALID WIDTH AND RESTART THE ASK FOR WIDTH PROCESS
INV_WIDTH:
	PSH#	PRT_INV_WIDTH_LEN	; OUTPUT INVALID WIDTH MESSAGE
	PSH#	PRT_INV_WIDTH		;
	JSR	PUT_STR			;
	JSR	PUT_NL			;
	JMP	GET_WIDTH		; JUMP TO GET WIDHT AGAIN
; IF SUCCESSFULL GET_WIDTH PROCEDE TO GET VALUE FROM USER
GET_VALUE:
	PSH#	PRT_VALUE_LEN		; OUTPUT VALUE MESSAGE
	PSH#	PRT_VALUE			;
	JSR	PUT_STR				;
	JSR	GET_NUM				;
	STA	N_VALUE				; STORE VALUE
	CMA#	000				; IF VALUE < 0 
	JLT	INV_VALUE			; OUTPUT INVALID VALUE MESSAGE ANG GET IT AGAIN
						; CHECK IF WIDTH HOLDS VALUE
	LDA#	0				;
	STA	N_TEMP				; N_TEMP = 0
	LDA#	1				;
	STA	N_TEMP2				; N_TEMP2 = 1
; LOOP TO CHECK FOR VALIDITY OF VALUE ENTERED INTO WIDHT
VAL_LOOP:
	CMA	N_WIDTH			;
	JEQ	VAL_LOOP_OUT		;
	LDA	N_TEMP2			; LOAD 1 INTO ACC
	SHLA				; SHIFT ACC TO LEFT
	STA	N_TEMP2			; N_TEMP2 = N_TEMP2 << 1
	LDA	N_TEMP			; N_TEMP++
	ADA#	1			;
	STA	N_TEMP			;
	JMP	VAL_LOOP		; CHECK LOOP CONDITION
; ONCE LOOP IS DONE SHIFTING 000001 TO LEFT
VAL_LOOP_OUT:					; COMPARE TO SEE IF VALUE FEETS INTO WIDTH
	LDA		N_TEMP2			; 
	CMA		N_VALUE			; N_TEMP2 ? N_VALUE
	JGE		VALUE_OBTINED		; IF '>' JUMP TO SUCESSFULL ADDED VALUE
	JMP		INV_VALUE		; IF '<' JUMP TO PRINT INV VALUE MESSAGE  
;
; OUTPUT INVALID VALUE MESSAGE AND RESTART GETTING VALUE
INV_VALUE:
	PSH#	PRT_INV_VALUE_LEN	; OUTPUT MESSAGE
	PSH#	PRT_INV_VALUE		;
	JSR	PUT_STR			;
	JSR	PUT_NL			;
	JMP	GET_VALUE		; START AGAIN PROCCESS OF GETTING VALUE
;
; ONCE VALUE HAS BEEN SUCCESSFULLY OBTAINED PROCEDE TO CODE IT AND STORE IT
VALUE_OBTINED:
	JSR		CODEIT
;
; AFTER CODEIT THE N_VALUE HAS BEEN CONVERTED TO 
; N_CODED VALUE STORING THE BINARY REFLECTED CODE
; NOW WE NEED TO ADD IT TO THE DATA WORD
;

; CONTINUE WITH PROGRAM INSETING CODED VALUE
; CHECK IF DATA WORD HAS ROOM
INS_CODE:	
	LDA		N_USED				; ACC = N_USED
	COMA						; ACC = NOT N_USED
	ADA#	1					; ACC = N_USED IN 2'S COMPLEMENT
	STA		N_TEMP				; N_TEMP = -N_USED
	LDA#	24					; ACC = 24
	ADA		N_TEMP				; ACC = ACC - N_TEMP
	CMA		N_WIDTH				; ACC ? N_WIDTH
	JGE		INS_CODED			; JUMP TO ADD THE CODED VALUE INTO DATA
	JLT		INS_OVERFLOW		; JUMP TO ADD THE CODED VALUE WHEN THE 
								; WIDTH IS GREATHER THAN THE SIZE OF CURRENT
								; WORD
;	
INS_CODED:
	LDA#	0			; START SHIFTING DATA
	STA	N_TEMP			; N_TEMP = 0
INS_COD_LOOP:				; DATA = DATA << WIDTH
	CMA	N_WIDTH			; ACC ? N_WIDTH
	JEQ	INS_COD_LOOP_OUT	; EXIT WHEN EQUAL
	LDA	DATA			; ACC = DATA
	SHLA				; ACC << 1
	STA	DATA			; DATA = ACC
	LDA	N_TEMP			; N_TEMP++
	ADA#	1
	STA	N_TEMP
	JMP	INS_COD_LOOP		; GO BACK TO TEST FOR LOOP
INS_COD_LOOP_OUT:
	LDA	DATA			; DATA |= CODED
	OR	N_CODED
	STA	DATA
	LDA	N_USED			; N_USED += N_WIDTH
	ADA	N_WIDTH
	STA	N_USED
	LDA	N_NEG_ONE			; N_WIDTH = -1
	STA	N_WIDTH				;
	JMP	CODED_ADDED			;
;
; IN CASE OF AN OVERFLOW OF THE WORD	
INS_OVERFLOW:
	LDA		N_USED				; ACC = N_USED
	COMA						; ACC = NOT N_USED
	ADA#	1					; ACC = N_USED IN 2'S COMPLEMENT
	STA		N_TEMP				; N_TEMP = -N_USED
	LDA#	MAXBITS				; ACC = 24
	ADA		N_TEMP				; ACC = ACC + -N_USED
	STA		N_PARTS				; N_PARTS = MAXBITS - N_USED
								;hold = coded >> (width - part);
	LDA		N_PARTS				;
	COMA						;
	ADA#	1					;
	STA		N_TEMP				; N_TEMP = -N_PARTS
	LDA		N_WIDTH				;
	ADA		N_TEMP				;
	STA		N_TEMP2				; N_TEMP2 = N_WIDTH - N_PARTS
SHIFT_PARTS:					;
	LDA		N_CODED				;
	STA		N_TEMP3				;
	LDA#	0					; START SHIFTING DATA
	STA		N_TEMP				; N_TEMP = 0
SHIFT_PARTS_LOOP:				; HOLD = CODED >> (WIDTH - PARTS)
	CMA		N_TEMP2				; ACC ? N_TEMP2 = W - P
	JEQ		SH_P_LOOP_OUT		; EXIT WHEN EQUAL
	LDA		N_TEMP3				; ACC = CODED
	SHRA						; ACC >> 1
	STA		N_TEMP3				; N_TEMP3 = ACC
	LDA		N_TEMP				; N_TEMP++
	ADA#	1					;
	STA		N_TEMP				;
	JMP	SHIFT_PARTS_LOOP		; GO BACK TO TEST FOR LOOP
SH_P_LOOP_OUT:					;
	LDA		N_TEMP3				;
	STA		N_HOLD				; HOLD = CODED << N_TEMP2 = W - P
	JMP		ROOM_PARTS			;
;	
;MAKE ROOM FOR PARTS
ROOM_PARTS:						;
	LDA#	0					; START SHIFTING DATA
	STA		N_TEMP				; N_TEMP = 0
ROOM_PARTS_LOOP:				; DATA = DATA << PARTS
	CMA		N_PARTS				; ACC ? N_PARTS
	JEQ		ROOM_PARTS_OUT		; EXIT WHEN EQUAL
	LDA		DATA				; ACC = DATA
	SHLA						; ACC << 1
	STA		DATA				; DATA = ACC
	LDA		N_TEMP				; N_TEMP++
	ADA#	1					;
	STA		N_TEMP				;
	JMP		ROOM_PARTS_LOOP		; GO BACK TO TEST FOR LOOP	
ROOM_PARTS_OUT:
	LDA		DATA				; DATA |= HOLD
	OR		N_HOLD				;
	STA		DATA				;
	LDA		N_USED				; N_USED += N_PARTS
	ADA		N_PARTS				;
	STA		N_USED				;
	LDA		N_PARTS				; coded = coded & ((1 << (width - part)) - 1);
	COMA						;
	ADA#	1					;
	STA		N_TEMP				; N_TEMP = -N_PARTS
	LDA		N_WIDTH				;
	ADA		N_TEMP				;
	STA		N_TEMP2				; N_TEMP2 = N_WIDTH - N_PARTS	
	LDA#	1					; N_TEMP3 = 1	
	STA		N_TEMP3				;
; START LOOP	
	LDA#	0					; SHIFT CODED
	STA		N_TEMP				; N_TEMP = 0
COD_S_LOOP:						; 
	CMA		N_TEMP2				; 
	JEQ		COD_S_OUT			; 
	LDA		N_TEMP3				; 
	SHLA						; 
	STA		N_TEMP3				; 
	LDA		N_TEMP				; 
	ADA#	1					;
	STA		N_TEMP				;
	JMP		COD_S_LOOP			; 
								; N_TEMP3 - 1
COD_S_OUT:						;
	LDA#	1					;
	COMA						;
	ADA#	1					; ACC = -1
	ADA		N_TEMP3				; ACC = -1 + N_TEMP3 ( 1 << N_TEMP2( WID - PAR) )
	AND		N_CODED				;
	STA		N_CODED				;
								; width -= part;
	LDA		N_PARTS				; ACC = PARTS
	COMA						; ACC = NOT PARTS
	ADA#	1					; ACC = - PARTS
	STA		N_TEMP				; TEMP = -PARTS
	LDA		N_WIDTH				; ACC = WIDTH
	ADA		N_TEMP				; ACC = WIDTH - PARTS
	STA		N_WIDTH				; WIDTH = ACC
	JMP		CODED_ADDED			;	
;
; ONCE THE CODE HAS BEEN ADDED
CODED_ADDED:
	LDA		N_USED				;
	CMA#	MAXBITS				;
	JEQ		N_USED_MAXBITS		; IF USED = 24 PRINT WORD CALL
	JMP		MAIN_LOOP			;
;	
N_USED_MAXBITS:
	LDA#	0
	STA		N_USED				; N_USED = 0
	JSR		HEXOUT				;
	JMP		MAIN_LOOP			; RESTART MAINLOOP
;
PRINT_WORD_EXIT:
	LDA		N_USED				; data = data << (MAXBITS - used);
	CMA#	0
	JEQ		EXIT				; EXIT PROGRAM
	COMA
	ADA#	1
	ADA#	MAXBITS				; ACC = MAXBITS - N_USED
	STA		N_TEMP2				; N_TEMP2 = MAXBITS - N_USED
	LDA		N_TEMP2
	LDA#	0					; START SHIFTING DATA
	STA		N_TEMP				; N_TEMP = 0
SWX:
	CMA		N_TEMP2				; ACC ? N_TEMP2
	JEQ		SWX_OUT				; EXIT WHEN EQUAL
	LDA		DATA				; ACC = DATA
	SHLA						; ACC << 1
	STA		DATA				; DATA = ACC
	LDA		N_TEMP				; N_TEMP++
	ADA#	1
	STA		N_TEMP
	JMP		SWX					; GO BACK TO TEST FOR LOOP	
SWX_OUT:
	JMP		HEXOUT				; OUTPUT THE WORD
;




; SUB
;
; CODEIT
; ======
;  THIS SUBRUTINE CONVERTS A N_VALUE INTO ITS
;  BINARY REFLECTED TO CODE EQUIVALENT
;  BY DOING AN SHIFT RIGHT AND XOR TO THE VALUE
;  THEN IT STORED ITS RESULT INTO THE VARIABLE N_CODED
CODEIT:
	LDA		N_VALUE			; LOAD THE ENTERED VALUE INTO ACC
	SHRA					; SHIFT ACC TO RIGHT
	XOR		N_VALUE			; XOR ACC 
	STA		N_CODED			; STORE BINARY REFLECTED CODE INTO N_CODED
	RTN
;	



; SUB
;
; HEXOUT
; ======
;  THIS SUBRUTINE PRINTS THE VALUE STORED INTO THE VARIABLE
;  DATA IN THE HEXADECIMAL FORMAT COUNTING BITS FROM HIGHEST
;  MOST VALUE (RIGHT) TO THE LOWER (LEFT).
;  THIS RUTINE SHIFTS LOADS THE VALUE DATA INTO THE ACC THEN
;  IT SHIFTS THE BITS TO THE RIGHT (STARTING THE FIRST 4 UNTIL
;  THE LAST 4) TO PRINT ITS EQUIVALENT VALUE INTO HEXADECIMAL
;  FORMAT.
;  THE VALUES FROM 0 TO 15 ARE COMPARED TO ITS EQUIVALENT HEX
;  VALUE AND THEN THE PROPER CHARACTER IS PRINT OUT.
;  DEPENDING IF THE VALUE IS GREATHER THAN 9, THE RUTINE USES
;  PUT_NUM2 OR PUT_STR FORM THE MINI_OS TO THE SCREEN.
;
HEXOUT:
	PSH#	PRT_WORD_LEN		; PUSH INTO STACK THE LENGTH OF THE STRING
	PSH#	PRT_WORD			; PUST INTO STACK THE STRING
	JSR		PUT_STR				; DISPLAY THE STRING FUNCTION CALL
	LDA#	0					; START LOOP
	STA		N_HEXOUT_COUNTER	; N_HEXOUT_COUNTER = 0	
;	
SHIFT_LOOP:						; SHIFTING NUMBERS LOOP
	CMA#	6					; ACC ? 6
	JEQ		OUT_SHIFT_LOOP		; ACC = 6 -> EXIT LOOP
								; ELSE
	LDA		DATA				; LOAD DATA INTO ACC
	STA		N_HEXOUT_DIGIT		; STORE DATA INTO HEXOUT_DIGIT
								; HEXOUT_DIGIT IS THE SHIFTED DIGIT TO BE 
								; CONVERTED INTO HEX EQUIVALENT AND OUTPUT
								; TO SCREEN
	LDA		N_HEXOUT_COUNTER	; ACC = LOOP COUNTER
;
; DETERMINE THE LOOP NUMBER
	CMA#	0					; SET THE NUMBER OF SHIFTING DEPENDING ON THE LOOP NUMBER  
	JEQ		SET_20				; JUMP TO SET SHIFTING VALUE TO 20
	CMA#	1					; THIS OPERATION IS REPEATED FOR EACH OF THE 6 
	JEQ		SET_16				; BITS TO BE PRINTED OUT
	CMA#	2					; THE SET_XX VALUES SET THE ACC TO SHIFT THE SPECIFIC
	JEQ		SET_12				; NUMBER OF TIMES THE DIGIT TO BE PRINTED OUT
	CMA#	3
	JEQ		SET_8
	CMA#	4
	JEQ		SET_4
	CMA#	5
	JEQ		SET_0
;	
; SET THE SHIFTING VALUE DEPENDING THE LOOP NUMBER
SET_20: 
	LDA#	20					; ACC = 20
	STA		N_HEXOUT_CHAR		; N_HEXOUT_CHAR = 20
	JMP		AFTER_SET			; JUMP TO SHIFT THE DIGIT 
SET_16:							; EACH ONE OF THS SET_XX FUNCTIONS
	LDA#	16					; SETS THE N_HEXOUT_CHAR VAR TO THE 
	STA		N_HEXOUT_CHAR		; NUMBER OF SHIFTS REQUIRED TO PRINT
	JMP		AFTER_SET			; THE NUMBER CONDITIONED BY THE 
SET_12:							; VALUE OF THE LOOP. EX: IN CASE OF
	LDA#	12					; FIRST NUMBER TO BE OUTPUT 
	STA		N_HEXOUT_CHAR		; THE SHIFTING MUST BE 20 TO THE RIGHT
	JMP		AFTER_SET			; WHICH IS SET BY SET_20, THEN THE 
SET_8:							; LABEL AFTER_SET PERFORMS THE OPERATION
	LDA#	8
	STA		N_HEXOUT_CHAR
	JMP		AFTER_SET
SET_4: 
	LDA#	4
	STA		N_HEXOUT_CHAR
	JMP		AFTER_SET
SET_0: 
	LDA#	0
	STA		N_HEXOUT_CHAR
	JMP		AFTER_SET
;
; PERFORMS THE OPERATION OF SHIFTING THE DIGIT TO BE PRINTED OUT
; CALLED AFTER THE N_HEXOUT_CHAR IS SET WITH THE VALUE TO BE
; SHIFTING.
AFTER_SET:
	LDA#	0						; START COUNTER FOR ACC TO BE SHIFTED
	STA		N_HEXOUT_COUNTER2		; STORE ACC INTO COUNTER
	;
	SHIFT_R:
		CMA		N_HEXOUT_CHAR		; ACC ? MAX(SHIFTING VALUE)
		JEQ		OUT_SHIFT			; WHILE  ACC <= SHIFTING VALUE 
		LDA		N_HEXOUT_DIGIT		; LOAD DIGIT INTO ACC
		SHRA						; SHIFT RIGHT ACC
		STA		N_HEXOUT_DIGIT		; STORE ACC INTO DIGIT
		LDA		N_HEXOUT_COUNTER2	; COUNTER++
		ADA#	1
		STA		N_HEXOUT_COUNTER2	
		JMP		SHIFT_R				; JUMP BACK TO LOOP BEGINING
	;	
	OUT_SHIFT:						; ONCE LOOP IS DONE
		LDA		N_HEXOUT_DIGIT		; LOAD SHIFTED DIGIT TO ACC
		AND		DIGITMASK			; CLEAR ALL HIGHER BITS
		CMA#	9
		JGT		SET_HEX_DIGIT		; IF GREATHER THAN 9 SET HEX DIGIT VALUE
		JMP		OUT_NUMBER			; ELSE PRINT THE NUMBER (ERROR CASE)

; ONCE THE DIGIT HAS BEEN SHIFTED THE REQUIERED NUMBER OF TIMES
; WE ARE READY TO PRINT IT OUT
; FIRST WE NEED TO CONVERT THE BINARY VALUE TO ITS EQUIVALENT 
; HEXADECIMAL TO BE PRINTED OUT
;
; THIS LABEL JUMPS DEPENDING THE DIGIT TO BE PRINTED
	SET_HEX_DIGIT:
		CMA#	10		; CASE ACC = 10
		JEQ		OUT_A	; JUMP TO PRINT OUT AN 'A'
		CMA#	11		; CASE ACC = 11
		JEQ		OUT_B	; JUMP TO PRINT OUT AN 'B'
		CMA#	12		; CASE ACC = 12
		JEQ		OUT_C	; JUMP TO PRINT OUT AN 'C'
		CMA#	13		; CASE ACC = 13
		JEQ		OUT_D	; JUMP TO PRINT OUT AN 'D'
		CMA#	14		; CASE ACC = 14
		JEQ		OUT_E	; JUMP TO PRINT OUT AN 'E'
		CMA#	15		; CASE ACC = 15
		JEQ		OUT_F	; JUMP TO PRINT OUT AN 'F'
		JMP		OUT_NUMBER
;
; THE OUT_X FUNCTION PUST INTO THE STACK THE EQUIVALENT HEX VALUE
	OUT_A:
		PSH#	HEX_10_LEN		; PUSH STACK 1
		PSH#	HEX_10			; PUSH STACK A CHAR
		JMP		HEX_SELECT_DONE ; JUMP ONCE THE SELECTION IS DONE
	OUT_B:
		PSH#	HEX_11_LEN
		PSH#	HEX_11			; PUSH STACK B CHAR
		JMP		HEX_SELECT_DONE
	OUT_C:
		PSH#	HEX_12_LEN
		PSH#	HEX_12			; PUSH STACK C CHAR
		JMP		HEX_SELECT_DONE
	OUT_D:
		PSH#	HEX_13_LEN
		PSH#	HEX_13			; PUSH STACK D CHAR
		JMP		HEX_SELECT_DONE
	OUT_E:
		PSH#	HEX_14_LEN
		PSH#	HEX_14			; PUSH STACK E CHAR
		JMP		HEX_SELECT_DONE
	OUT_F:
		PSH#	HEX_15_LEN
		PSH#	HEX_15			; PUSH STACK F CHAR
		JMP		HEX_SELECT_DONE
;		
; AFTER THE SELECTION IS DONE
; THE CHARACTER CAN BE PUT OUT
;
	HEX_SELECT_DONE:	
		JSR		PUT_STR				; CALL PRINT CHAR
		JMP		HEX_FINISH			; JUMP TO PRINT ACC OUT
;	
; THIS LABEL OUTPUTS A NUMBER IN THE SCREEN WHEN THE VALUE IS LESS
; THAN 10 ( FROM 0 TO 9 )
	OUT_NUMBER:
		PSH#	1					; SET OUTPUT TO ONE CHAR LENGTH
		PSHA						; STORE ACC IN STACK
		JSR		PUT_NUM2			; CALL FUNC TO OUTPUT ACC
		JMP		HEX_FINISH			; EXIT LOOP OF PRINTING ONE DIGIT (HEX) OUT
;
HEX_FINISH:	
	LDA		N_HEXOUT_COUNTER		; LOAD 0 TO 6 COUNTER
	ADA#	1						; N_HEXOUT_COUNTER++
	STA		N_HEXOUT_COUNTER		; 
	JMP		SHIFT_LOOP				; START LOOP FOR NEXT CHARACTER
;
; ONCE THE PRINTING OUT IS DONE
; WE CAN EXIT THE PRINTING OUT FUNCTION AND GO BACK TO GET_WIDTH
OUT_SHIFT_LOOP:
	JSR		PUT_NL					
	LDA		N_WIDTH
	CMA#	0
	JEQ		EXIT
	JMP		MAIN_LOOP
	RTN
;
; VARIABLE DEFINITION FOR HEXOUT
;
N_HEXOUT_DIGIT		:	.WORD	0
N_HEXOUT_COUNTER	:	.WORD	0
N_HEXOUT_COUNTER2	:	.WORD	0
N_HEXOUT_CHAR		:	.WORD	0
PRT_WORD		    :   .CHAR   'Word = ', PRT_WORD_LEN
;
;
; ONCE THE WIDHT = 0, EXIT APP
EXIT:
	JSR		PUT_NL
	PSH#    PRT_GOODBYE_LEN
    PSH#    PRT_GOODBYE
    JSR     PUT_STR
    JSR		PUT_NL
    JSR		PUT_NL
    HLT
;	
	
; VARIRABLE DEFINITIONS FOR PROGRAM
;
PRT_PRG     :   .CHAR    'GRAY-CODE ENCODER', PRTPRG_LEN
PRT_WIDTH   :   .CHAR	'Width', PRT_WIDTH_LEN
PRT_VALUE   :   .CHAR	'Value', PRT_VALUE_LEN
PRT_GOODBYE :   .CHAR	'Good Bye!', PRT_GOODBYE_LEN
PRT_INV_WIDTH:  .CHAR	'Invalid width', PRT_INV_WIDTH_LEN
PRT_INV_VALUE:  .CHAR	'Invalid value', PRT_INV_VALUE_LEN
;
HEX_10:			   .CHAR	'A', HEX_10_LEN
HEX_11:			   .CHAR	'B', HEX_11_LEN
HEX_12:			   .CHAR	'C', HEX_12_LEN
HEX_13:			   .CHAR	'D', HEX_13_LEN
HEX_14:			   .CHAR	'E', HEX_14_LEN
HEX_15:			   .CHAR	'F', HEX_15_LEN
;
N_WIDTH :		   .WORD	-1
N_VALUE :		   .WORD	0
N_CODED :		   .WORD	0
N_HOLD  :		   .WORD	0
N_PARTS :		   .WORD	0
N_USED  :		   .WORD	0
N_TEMP	:		   .WORD	0
N_TEMP2	:		   .WORD	0
N_TEMP3 :		   .WORD	0
N_NEG_ONE:		   .WORD	-1
;
DIGITMASK:		   .WORD	$00000F	
DATA    :		   .WORD	0
;
