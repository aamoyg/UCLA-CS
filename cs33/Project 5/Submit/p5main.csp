;**************************************************************************
;
; FILE:		P5MAIN.CSP
;
; DESCRIPTION:	PROJECT 5 MAIN PROGRAM
;
; AUTHOR:	R. JAVIER VEGA
;
; SID:	003-110-717
;**************************************************************************

;			// CRT I/O PORTS
			.EQU	X_POS,		$314
			.EQU	Y_POS,		$315
			.EQU	CRT_CTRL,	$316
			.EQU	CRT_DATA,	$317
			
;			// KEYBOARD I/O PORTS
			.EQU	KBD_STAT,	$000
			.EQU	KBD_DATA,	$001

;			// PROGRAM CONSTANTS
			.EQU	@,			$000
			.EQU	ZERO,		$000
			.EQU	ONE,		$001
			.EQU	ROWS,		9
			.EQU	COLS,		8
			.EQU	TOT_CELLS,	ROWS * COLS
			
;			// KEYBOARD CONSTANTS
			.EQU		ESC,		$1B
			.EQU		UP_ARW,		'H'
			.EQU		DN_ARW,		'P'
			.EQU		LT_ARW,		'K'
			.EQU		RT_ARW,		'M'
			.EQU		PLUS,		'+'
			.EQU		MINUS,		'-'
			.EQU		MULT,		'*'
			.EQU		DIVIDE,		'/'
			.EQU		NEW_DATA,	'N'
			.EQU		ENTER,		$0D

;			// SCREEN MAP CONSTANTS
			.EQU		CRT_OPER,	$2F9			; POSITION WHERE TO START THE OPERATION STRINGS

			
;			// FUNCTION CALLS
			.EQU	MOVE_CELL,		$A00			
			.EQU	SET_CELL,		$A01
			.EQU	BEEP_MSG,		$A02
			.EQU	CLEAR_BELL,		$A03
			.EQU	SHOW_CURR_CELL,	$A04
			.EQU	SHOW_CELL_VAL,	$A05
			.EQU	UPDATE_TOTS,	$A06
						
;			// MAIN PROGRAM
			LDS#	$F00				; SET STACK POSSITION
MAIN:		SBS#	TOT_CELLS			; SPACE ON STACK TO STORE THE CELLS
			STS		CELL_ARRAY			;

RESTART:
			LDA#	$01					; CLEAR SCREEN BUFFER
			OUTB	CRT_CTRL			;

			LDA#	0
			LDX#	0					; EMPTY CELL_ARRAY
CLR_CELLS:	CMX#	TOT_CELLS			;
			JGE		@ + 4
			STA&	CELL_ARRAY
			ADX#	1
			JMP		CLR_CELLS
						
			LDA#	0					; OUTPUT THE LAYOUT OF THE SCREEN
			LDX#	0
LAYOUT:		CMX#	(38*14) + 12		; PRINT THE ARRAY OF STRINGS = TOTAL NUM OF SPACES PLUS SKIPED ONES (12)
			JGE		DONE_L				; STORED IN THE CHARS VARIABLES
			CMA#	38					; IN CASE THE LAST CHAR IS PRINTED, SKIP PRITING 
			JEQ		SKIP				; A BLANK SPACE
			PSHA						; SAVE ACC
			LDC		T_STR				; LOAD CHAR ( TITLE STRINGS )
			OUTB	CRT_DATA			; PRINT CHAR
			POPA						; RESTORE ACC
			ADA#	1					; INCREASE COUNTER AND INDEX
			ADX#	1
			JMP		LAYOUT				; LOOP BACK
SKIP:		ADX#	1					; DON'T PRINT THE CURRENT CHAR
			LDA#	0
			JMP		LAYOUT				; LOOP BACK
DONE_L:


;	// SET CELL POSITION ( 1, 1 )
			LDA#	1					; INITIAL POSITION OF CELL = ( 1, 1 )
			STA		X_CURR_CELL
			STA		Y_CURR_CELL

			PSH		X_CURR_CELL			; SET_CURSON IN RESPECTIVE CELL
			PSH		Y_CURR_CELL			; PASS VALUES BY REFERENCES
			JSR		SET_CELL	
			ADS#	2

			
;	// START INPUT READ FROM KEYBOARD

			LDA#	$40					; FLUSH KEYBOARD BUFFER
			OUTB	KBD_STAT
KEY_POLL:	INB		KBD_STAT			; LOOP FOR KEYBOARD INPUT
			JGE		KEY_POLL			;
			INB		KBD_DATA			;
			
			CMA#	'q'					; ONCE THE BUFFER HAS A VALID KEY 
			JEQ		QUIT				; GO AND TEST FOR RELEVANT KEYS ELSE BEEP SCREEN
			CMA#	'Q'
			JEQ		QUIT				; EXIT PROGRAM ON 'Q, q' KEY
			
			CMA#	'r'					
			JEQ		RESET				
			CMA#	'R'					
			JEQ		RESET				; RESET PROGRAM ON 'R, r' KEY
			
			CMA#	'c'
			JEQ		CLR_CELL			; CLEAR CELLS ON 'C, c' KEY
			CMA#	'C'
			JEQ		CLR_CELL
			
			CMA#	PLUS				; IF PLUS BUTTON PRESS
			JEQ		OPERAND				; JUMP TO PROCESS OPERANDS
			
			CMA#	MINUS				; IF MINUS 
			JEQ		OPERAND
			
			CMA#	MULT				; IF MULT
			JEQ		OPERAND
			
			CMA#	DIVIDE				; IF DIVISION 
			JEQ		OPERAND				; JUMP TO PROCESS OPERANS
			
			CMA#	ESC					; PROCESS COMBINATION KEYS (UP, DOWN, LEFT, RIGHT, ECT...)
			JEQ		ARRW_PRES			;	
													
			CMA#	'0'					; IF NO MAJOR CHARACTER IS PRESS
			JLT		INV_INPUT			; CHECK FOR NUMBER INPUT
			CMA#	'9'
			JGT		INV_INPUT
										; ELSE THE NUMBER IS VALID
			STA		TEMP_NUM			; STORE THE NUMBER ENTERED
			LDA#	NEW_DATA			; SET OPERAND TO NEW_DATA
			STA		OP					; SET OPERATION TO NEW_DATA ( VALID NUMBER ENTERED )
			LDA		TEMP_NUM
			JMP		GET_NUM				; GO GET THE NUMBER RUTINE
			
INV_INPUT:	JSR		BEEP_MSG			; ELSE INVALID INPUT MESSAGE
			JNE		KEY_POLL			; START KEY POLLING AGAIN


; // PROCESS KEYS 
;

; IN CASE AN OPERAND HAS BEEN PRESS
OPERAND	:	PSHA						; SAVE VALUES
			PSHX
			STA		OP					; SAVE THE COMAND SEND INTO OP
			LDX#	0					; DISPLAY THE MESSAGE OF OPERATION
			CMX#	OP_STRL				;
			JGE		@ + 5				;
			LDC 	OP_STR				;	
			OUTB+	CRT_OPER			; $2F9 CODE WHERE TO START DISPLAYING OP_STRING
			ADX#	1					;
			JMP		@ - 5				;
			LDA		OP					; DISPLAY THE OPERAND TO DO
			OUTB+	CRT_OPER			;
			LDX#	0					; DISPLAY VALUE STRING 
			CMX#	VAL_STRL			;
			JGE		@ + 5
			LDC 	VAL_STR
			OUTB+	$306
			ADX#	1
			JMP		@ - 5
			POPX						; RESTORE VALUE USED
			POPA						;

; // ONCE THE CHARACTERS HAVE BEEN DISPLAYED 
; // PROCEDE TO PERFORM THE OPERATION

; // GET THE NEXT CHARACTER TO GET THE NUMBER
DO_OPERAND:
			INB		KBD_STAT				; KEYBOARD LOOPING FOR NUMBER INPUTS
			JGE		@ - 1					;
			INB		KBD_DATA				;
			CMA#	'x'
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			CMA#	'X'
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			CMA#	'0'						; CHECK FOR NUMBER INPUT
			JLT		NO_NUM1					;
			CMA#	'9'
			JGT		NO_NUM1
			STA		TEMP_NUM				; IN CASE OF VALID NUMBER STORE IT INTO TEMP_NUM
			CLR		TEMP_CELL				; CLEAR TEMP_CELL VALUE
			LDA		TEMP_NUM				; LOAD ACC WITH THE NUMBER ENTERED
			JMP		GET_NUM					; JUMP TO GET NUMBERS CODE
NO_NUM1:	JSR		BEEP_MSG				; IN CASE OF INVALID NUMBER ENTERED BEEP MESSAGE
			JMP		DO_OPERAND				; GO BACK FOR KEYBOARD LOOPING
;


;	// CODE FOR CLEARING THE VALUE OF A CELL
CLR_CELL:	PSHA
			PSHX
			LDX#	0						; DISPLAY THE OPERATION TO SCREEN
			CMX#	OP_STRL					;
			JGE		@ + 5					;
			LDC 	OP_STR					;
			OUTB+	CRT_OPER				;
			ADX#	1						;
			JMP		@ - 5					;
			LDA#	'C'						;
			OUTB+	CRT_OPER				;
			POPX
			POPA
			
;	// CHECK FOR INPUT 'ENTER OR X'
C_LOOP:		INB		KBD_STAT				; KEYBOARD LOOPING
			JGE		C_LOOP
			INB		KBD_DATA
			CMA#	ENTER
			JEQ		DO_CLR					; EXIT PROGRAM ON 'Q' KEY
			CMA#	'x'	
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			CMA#	'X'
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			JSR		BEEP_MSG
			JMP		R_LOOP
DO_CLR:		LDA		Y_CURR_CELL				; STORE THE ZERO VALUE IN THE CELL_ARRAY
			SBA#	1						; CALCULATE WHERE IN THE ARRAY
			MUL#	8						;
			ADA		X_CURR_CELL				;
			SBA#	1						;
			STA		TEMP_INDEX				; STORE THE INDEX VALUE INTO TEMP_INDEX
			LDX		TEMP_INDEX
			LDA#	0
			STA&	CELL_ARRAY				; STORE THE ZERO
			LDA#	' '						; CLEAR THE CELL VALUE IN DISPLAY
			PSHA							;
			JSR		UPDATE_CONT				; CALL FUNCTION TO UPDATE CONTENT OF THE CELL
			POPA
			PSH		X_CURR_CELL				; CALL FUNCTION TO UPDATE TOTALS AND DISPLAYS
			PSH		Y_CURR_CELL
			PSH		CELL_ARRAY
			JSR		UPDATE_TOTS
			ADS#	3
			PSH		X_CURR_CELL				; CALL THE FUNCTION TO SHOW THE CELL VALUE INTO THE BOX
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL
			ADS#	2
			JSR		CRL_BOTTOM				; CLEAR THE OPERATION MESAGE ONCE DONE
			JMP		KEY_POLL				; GO BACK TO LOOPING KEYS
;//	DONE CLEARING CELL


;	// CODE PROCCESS THE QUITING OF THE PROGRAM
QUIT:		PSHA
			PSHX
			LDX#	0						; DISPLAY THE OPERATION QUIT ON THE SCREEN
			CMX#	OP_STRL					;
			JGE		@ + 5					;
			LDC 	OP_STR					; DISPLAY THE OPERAND Q
			OUTB+	CRT_OPER				;
			ADX#	1						;
			JMP		@ - 5					;
			LDA#	'Q'						;
			OUTB+	CRT_OPER				;
			POPX
			POPA
;	// CHECK FOR INPUT 'ENTER OR X'
Q_LOOP:		INB		KBD_STAT				; KEY INPUT LOOP
			JGE		Q_LOOP
			INB		KBD_DATA
			CMA#	ENTER
			JEQ		EXIT					; EXIT PROGRAM ON 'Q' KEY
			CMA#	'x'						;
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			CMA#	'X'						;
			JEQ		CANCEL_OP				; CANCEL OPERATION 
			JSR		BEEP_MSG				; INVALID INPUT 
			JMP		R_LOOP					; START LOOPING KEYS AGAIN
;// END QUIT	



;	// CODE PROCCESS THE REST OF THE CELLS
RESET:		PSHA
			PSHX
			LDX#	0						; DISPLAYING OF THE OPERATION
			CMX#	OP_STRL					;
			JGE		@ + 5					;
			LDC 	OP_STR
			OUTB+	CRT_OPER
			ADX#	1
			JMP		@ - 5
			LDA#	'R'
			OUTB+	CRT_OPER	
			POPX
			POPA
;	// CHECK FOR INPUT 'ENTER OR X'
R_LOOP:			INB		KBD_STAT
			JGE		R_LOOP
			INB		KBD_DATA
			CMA#	ENTER
			JEQ		RESTART				; EXIT PROGRAM ON 'Q' KEY
			CMA#	'x'
			JEQ		CANCEL_OP			; CANCEL OPERATION 
			CMA#	'X'
			JEQ		CANCEL_OP			; CANCEL OPERATION 
			JSR		BEEP_MSG
			JMP		R_LOOP
;// END RESET



;	//	CANCELS THE ANY OPERATION GOING BACK TO PULL KEYS
CANCEL_OP:	JSR		CRL_BOTTOM			; CLEAR THE OPERATION TO BE PERFORMED CRT
			JMP		KEY_POLL


;	// PROCESS ARROW KEY MOVE MENTS
ARRW_PRES:	INB		KBD_DATA			; ONCE AN ESC KEY HAS BEEN PRESS, PROCESS THE NEXT VALUE
			CMA#	RT_ARW				; IF RIGHT ARROW
			JEQ		MOV_RT				; MOVE TO THE RIGHT 
			CMA#	LT_ARW				; IF LEFT ARROW 
			JEQ		MOV_LT				; MOVE TO THE LEFT
			CMA#	UP_ARW				; IF UP ARROW
			JEQ		MOV_UP				; MOVE UP
			CMA#	DN_ARW				; IF DOWN ARROW
			JEQ		MOV_DN				; MOVE DOWN THE CURSOR
			JMP		KEY_POLL			; JUMP BACK TO LOOP KEYS


;	// THE NEXT FOLLOWING LABELS CALL THE MOVE CELL FUNTION 
;	// WITH THE RESPECTIVE UP OR DOWN VALUES
;

MOV_RT:		PSH#	ONE
			PSH#	ZERO
			PSH#	X_CURR_CELL
			PSH#	Y_CURR_CELL
			JSR		MOVE_CELL			; // CALL MOVE CELL ( 1, 0, &X, &Y )
			ADS#	4
			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; // UPDATE THE CURRENT VALUE OF THE NEXT CELL
			ADS#	2
			JMP		KEY_POLL
MOV_LT:		PSH		NEG_ONE
			PSH#	ZERO
			PSH#	X_CURR_CELL
			PSH#	Y_CURR_CELL
			JSR		MOVE_CELL			; //CALL MOVE CELL 	
			ADS#	4
			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; // UPDATE THE CURRENT VALUE OF THE NEXT CELL
			ADS#	2
			JMP		KEY_POLL
MOV_UP:		PSH#	ZERO
			PSH		NEG_ONE
			PSH#	X_CURR_CELL
			PSH#	Y_CURR_CELL
			JSR		MOVE_CELL			; // CALL MOVE CELL ( 1, 0, &X, &Y )
			ADS#	4
			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; // UPDATE THE CURRENT VALUE OF THE NEXT CELL
			ADS#	2
			JMP		KEY_POLL
MOV_DN:		PSH#	ZERO
			PSH#	ONE
			PSH#	X_CURR_CELL
			PSH#	Y_CURR_CELL
			JSR		MOVE_CELL			; // CALL MOVE CELL ( 1, 0, &X, &Y )
			ADS#	4
			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; // UPDATE THE CURRENT VALUE OF THE NEXT CELL
			ADS#	2

			JMP		KEY_POLL			; ONCE DONE GO BACK TO LOOP KEYS


; // CODE TO GET THE NUMBER FROM THE KEYBORD
; // NUMBER ALREADY STORED INTO TEMP_NUM
GET_NUM:	
			STA		TEMP_NUM			; STORE THE FIRT INPUT NUMBER INTO TEMP_CELL
			LDX#	2
			STX		TEMP_INDEX
			STC		TEMP_CELL
			JSR		NEW_VALUE
			JSR		SHOW_IN_VALUE		; SHOW THE VALUE INTO DISPLAY 
			
GET_NEXT:	INB		KBD_STAT			; GET NEXT NUMBER
			JGE		@ - 1				;
			INB		KBD_DATA			;
			STA		TEMP_NUM			;
			
			CMA#	ENTER				; PROCESS SPECIAL KEY
			JEQ		ENTER_KEY			;
			
			CMA#	'X'					;
			JEQ		CANCEL_NUM			;
										; CHECK FOR NUMBER INPUT
			CMA#	'0'					;
			JLT		GNO_NUM				;
			CMA#	'9'					;
			JGT		GNO_NUM				;
			
			JMP		ADD_NEXT			; ADD A NEXT NUMBER
	
GNO_NUM:	JSR		BEEP_MSG
			JMP		GET_NEXT			; GO GET THE NEXT NUMBER

CANCEL_NUM:	CLR		TEMP_CELL			; CANCEL OPEARTION
			JMP		CANCEL_OP
			
ADD_NEXT:	LDX		TEMP_INDEX			; ADD THE NEXT ENTERED NUMBER TO TEMP_CELL
			SBX#	1					;
			CMX#	$FFF				;
			JEQ		TOO_MANY			; IN CASE MORE THAN THREE NUMBER ARE ATTTEMPT TO BE ENTERED

			STX		TEMP_INDEX			; ELSE STORE THE INDEX OF THE POSSITION TO BE ENTERED

			PSHX
			LDA		TEMP_CELL			; SHIFT TEMP_CELL TO LEFT 8 BITS TO MAKE SPACE FOR NEW CHAR
			LDX#	0					;
			CMX#	8					;
			JEQ		@ + 4				;
			SHLA
			ADX#	1
			JMP		@ - 4
			STA		TEMP_CELL			; STORE THE NEW VALUE INTO THE TEMPORARY CELL
			LDA		TEMP_NUM			; 
			LDX#	2
			STC		TEMP_CELL
			JSR		SHOW_IN_VALUE		; SHOW THE VALUE ENTERED
			POPX
			
			JMP		GET_NEXT			; GET THE NEXT NUMBER ENTERED

TOO_MANY:	JSR		BEEP_MSG
			JMP		GET_NEXT


ENTER_KEY:	
			; NOTE:		TEMP_CELL
			; HAS THE VALUE ENTERED IN DECIMAL CHARS NOT THE ACTUAL NUMBER.
			;

			PSH		TEMP_CELL
			JSR		SHOW_CURR_CELL		; SHOW THE CELL VALUE JUST INSERTED
			POP		TEMP_CELL
			
			PSH		TEMP_CELL
			JSR		ST_VAL				; STORE THE ARITH VALUE INTO THE CURRENT CELL
										; PERFORMING THE OPERATION STORE IN OP
			POP		TEMP_CELL

			PSH		TEMP_CELL
			JSR		UPDATE_CONT			; UPDATE THE SPECIFIC CELL CONTENT 
			POP		TEMP_CELL			

			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			PSH		CELL_ARRAY
			JSR		UPDATE_TOTS			; UPDATE TOTALS
			ADS#	3
			
			JSR		CRL_BOTTOM			; IN CASE OF AN OPERAND SEND
			JSR		CLEAR_BELL			; DO NOT MOVE TO THE NEXT CELL
			LDA#	0
			STA		TEMP_CELL

			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; SHOW THE VALUE OF THE CELL
			ADS#	2

			LDA	OP
			CMA#	NEW_DATA			; PERFORM THE OPERATION IN THE CELL_ARRAY LOAD WITH NEW_DATA
			JNE		KEY_POLL			; IF NOT START POLLING INPUT

			LDA		X_CURR_CELL			; THIS CODE CALCULATES THE NEXTT LOGIC POSSITION OF THE
			CMA#	8					; CURSOR
			JGE		SET_ZERO			; START ROW = 0
			JMP		NEXT_POS			; ELSE NEXT ROW + 1
			
SET_ZERO:	LDA#	0					; CALCULATE THE NEXT LOGICAL ADDRESS IN THE CELL STRUCTURE
			STA		X_CURR_CELL			; SET X_CURR_CELL TO INITIAL POSSITION
			LDA		Y_CURR_CELL			; CHECK FOR THE LAST COL
			ADA#	1					;
			CMA#	10					;	
			JGE		@+3					; IF IT IS THE LAST COL AND THE LAST ROW
			STA		Y_CURR_CELL			; JUMP TO ELSE SET Y = 1
			JMP		NEXT_POS

			LDA#	1					; ELSE SET Y = 1
			STA		Y_CURR_CELL			;			

NEXT_POS:	PSH#	ONE					; ELSE MOVE TO NEXT LOGICAL POSSITION
			PSH#	ZERO
			PSH#	X_CURR_CELL
			PSH#	Y_CURR_CELL
			JSR		MOVE_CELL
			ADS#	4
			
			PSH		X_CURR_CELL
			PSH		Y_CURR_CELL
			JSR		SHOW_CELL_VAL		; SHOW THE VALUE OF THE CELL
			ADS#	2

			JMP		KEY_POLL

EXIT:		ADS#	TOT_CELLS
			HLT			


; // PROGRAM VARIABLES
;

X_CURR_CELL			:		.WORD	0			;	X POSITION OF CURRENT CELL
Y_CURR_CELL			:		.WORD	0			;	Y POSITION OF CURRENT CELL
CELL_ARRAY			:		.WORD	0			;	LOCATION IN STACK FOR CELLS ARRAY
TEMP_CELL			:		.WORD	0			;	TEMPORARY FILLING ON INPUT CELL
TEMP_NUM			:		.WORD	0			;	TEMPORARY INSERTING NUMBER
TEMP_INDEX			:		.WORD	0			;	TEMPORARY INDEX FOR INSERTING VALUES
TEMP				:		.WORD	0			;	TEMP VAR FOR VARIOUS POURPOSES
OP					:		.WORD	0			;	STORE THE OPERATION TO BE DONE
MAX_NEG				:		.WORD	-999		;	MAXIMUN NEGATIVE VALUE ALLOWED
NEG_ONE				:		.WORD	-1			;	MINUS ONE VAR USED AS CONSTANT

; // STRING CONSTANTS
;

T_STR			:		.CHAR		'CS 33 SPRING ''03 PROJECT 5 SPREADSHEET', T_LEN
C0				:		.CHAR		'     1   2   3   4   5   6   7   8 TOT',  C0L
C1				:		.CHAR		'1                                    0',  C1L
C2				:		.CHAR		'2                                    0',  C2L
C3				:		.CHAR		'3                                    0',  C3L
C4				:		.CHAR		'4                                    0',  C4L
C5				:		.CHAR		'5                                    0',  C5L
C6				:		.CHAR		'6                                    0',  C6L
C7				:		.CHAR		'7                                    0',  C7L
C8				:		.CHAR		'8                                    0',  C8L
C9				:		.CHAR		'9                                    0',  C9L
CT				:		.CHAR		'T    0   0   0   0   0   0   0   0   0',  CTL
CC				:		.CHAR		'Current:   Row 1  Column 1  Value     ',  CCL
COL_N			:		.CHAR		'Next:                                 ',  COLNL
ND_STR			:		.CHAR		'New Data         Value',			       ND_STRL					
OP_STR			:		.CHAR		'Operation ',							   OP_STRL
VAL_STR			:		.CHAR		'    Value',							   VAL_STRL




;**************************************************************************
;
;	FUNCTIONS DECLARED WITHIN THE MAIN FUNCTION
;	NOTE THIS FUNCTIONS USE PARAMETERS OF THE GLOBAL 
;	VARIABLES DEFINED AND USED BY THE MAIN PROGRAM.
;	THE FUNCTIONS DECLARED IN THE FILE P5SUB1.CSP
;	USE PARAMETER PASSING SINCE THEY ARE STORED IN A DIFFERENT
;	OBJECT CODE FILE.
;
;**************************************************************************


;	UPDATE_CONTENT
;
;	//	THIS FUNCTION UPDATES THE CONTENT OF THE CURRENT CELL
;	//	WITH THE SPECIFIC VALUE ENTERED.
;	//	THIS FUNCTION WORKS WITH THE VALUE OF THE SCREEN
;	//	THAT ARE IN THE VALUE BOX FOR BROWSING THE
;	//	SPREADSHEET MATRIX.
;	

.EQU	TO_SHOW,	0

UPDATE_CONT:
			BGN#	1
			PSHA
			PSHX
			LDA		Y_CURR_CELL		; CALCULATE THE VALUE OF THE CURRENT CELL
			SBA#	1
			MUL#	8
			ADA		X_CURR_CELL
			SBA#	1
			STA		TEMP
			LDX		TEMP
			LDA&	CELL_ARRAY
			CMA#	999				; CHECK FOR STARTS ON INVALID VALUE
			JGT		STRS
			CMA		MAX_NEG	
			JLT		STRS
			JMP		OK				; ELSE IT IS GOOD VALUE TO BE DISPLAYED

STRS:		LDA#	4				; CALCULATE THE INDEX WHERE TO PUT THE STARTS
			MUL		X_CURR_CELL		;
			ADA#	$25				;
			STA		TEMP			;
			LDA#	38				;
			MUL		Y_CURR_CELL		;
			ADA		TEMP			;
			STA		TEMP			;
			LDX		TEMP
			LDA#	' '				; EMPTY THE NEGATIVE SPACE BLOCK
			SBX#	1
			OUTB+	$100
			LDA#	'*'				; LOAD CHARACTER *
			LDX		TEMP
			OUTB+	$100			; DISPLAY CHARACTHER ***
			ADX#	1				;
			OUTB+	$100			;
			ADX#	1				;
			OUTB+	$100			;
			JMP		OUT_UP			; EXIT THE FUCNTION ONCE THE STARS HAVE BEEN DISPLAYED

OK:			PSHA					; NUMBER IS VALID TO BE DISPLAYED
			LDA#	0
			STA		TEMP_INDEX
			POPA
			CMA#	0
			JLT		IS_NEG			; CHECK IF IT IS POSSITIVE OR NEGATIVE
			JMP		POS

IS_NEG:		COMA					; IF NEGATIVE
			ADA#	1				; CONVERT VALUE TO POSITIVE FOR DISPLAY
			PSHA
			LDA#	1				; SET NEGATIVE SIMBOL ON
			STA		TEMP_INDEX		; SET TEMP IDEX TO 1 ( INDICATES DISPLAY - SIMBOL )
			POPA						
POS:		PSHA					; IF POSSITIVE

			MOD#	100				; CALCULATE THE FIRST NUMERICAL VAUE
			MOD#	10
			STA		TEMP_NUM		; STORE IT ON TEMP_NUM
			ADA#	'0'	
			LDX#	2
			STC		!TO_SHOW		; STORE THE CHARACTER IN TO_SHOW VAR
			POPA
			
			SBA		TEMP_NUM		; SUBSTRACT THE NUMBER FROM THE TOTAL NUMBER
			
			CMA#	100
			JLT		ANEXT_NUM		; CHECK IF IT IS ONLY POWER OF 10^2
			PSHA					;	
			MOD#	100				;
			CMA#	0				;
			JGT		APOPN_NUM		;
			LDA#	'0'				;
			LDX#	1
			STC		!TO_SHOW		; IF NOT CALCULATE THE NUMBER
			OUTB	$2EC
			POPA
			JMP		ALAST_NUM		; CALCULATE THE LAST NUMBER
			
APOPN_NUM:	POPA
ANEXT_NUM:	PSHA					; 
			MOD#	100				;
			DIV#	10				;
			ADA#	'0'				;
			CMA#	'0'				; IF THE NUMBER IS NOT ZERO THEN DISPLAY IT
			JNE		@ + 2			; DO NOT DISPLAY IT
			LDA#	' '				; DISPLAY EMPTY SPACE ON ITS PLACE
			LDX#	1				;
			STC		!TO_SHOW		; ELSE SHOW THE NUMBER
			SBA#	'0'				;
			STA		TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
			
ALAST_NUM:	PSHA					; PROCESS THE LAST NUMBER
			DIV#	100
			ADA#	'0'
			CMA#	'0'
			JNE		@ + 2			; IF IT IS NOT ZERO 
			LDA#	' '				; SHOW THE BLANK SPACE
			LDX#	0
			STC		!TO_SHOW		; STORE THE NUMBER TO BE DISPLAYED
			SBA#	'0'
			STA		TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA

			LDA#	4				; OUTPUT THE CHARACTERS IN TO THE
			MUL		X_CURR_CELL		; RESPECTIVE POSSITION FROM TO_SHOW	
			ADA#	$25				;
			STA		TEMP			;
			LDA#	38				;
			MUL		Y_CURR_CELL		;
			ADA		TEMP			;
			STA		TEMP			;
			LDA#	' '				; CLEAR THE NEGATIVE NUMBER IN CASE OF HUNDRED TYPE VALUE
			LDX		TEMP
			SBX#	1
			OUTB+	$100			; SHOW THE FIRST NUMBER
			LDX#	0
			LDC		!TO_SHOW
			LDX		TEMP
			OUTB+	$100			; SHOW THE SECOND NUMBER
			LDX#	1
			LDC		!TO_SHOW
			LDX		TEMP
			ADX#	1
			OUTB+	$100			; SHOW THE THIRD NUMBER
			LDX#	2
			LDC		!TO_SHOW
			LDX		TEMP
			ADX#	2
			OUTB+	$100			;

			LDA		TEMP_INDEX
			CMA#	0				; IF NEGATIVE PROCCEDDE TO SHOW SYMBOL 
			JEQ		OUT_UP			; GO TO POPX

			LDX#	1				; CALCULATE WHRE TO PLACE THE - SYMBOL
			LDC		!TO_SHOW		;
			CMA#	' '				;
			JNE		@ + 6
			
			LDA#	'-'				; DISPLAY THE SYMBOL
			LDX		TEMP			;
			ADX#	1				;
			OUTB+	$100			;
			JMP		OUT_UP
			
			LDX#	0
			LDC		!TO_SHOW
			CMA#	' '
			JNE		@ + 5
			LDA#	'-'				; DISPLAY THE SYMBOL
			LDX		TEMP			;
			OUTB+	$100			;
			JMP		OUT_UP		

			LDA#	'-'				; DISPLAY THE SYMBOL
			LDX		TEMP			;
			SBX#	1				;
			OUTB+	$100			;

OUT_UP:		POPX					; DONE WITH FUNCTION
			POPA
			FIN#	1
			RTN





;	STORE_VALUE
;
;	//	THIS FUNCTION STORES THE CONTENT OF THE CELL
;	//	WITH THE SPECIFIC VALUE ENTERED.
;	//	THIS FUNCTION WORKS WITH THE VALUE OF THE SCREEN
;	//	THAT ARE IN THE VALUE BOX FOR BROWSING THE
;	//	SPREADSHEET MATRIX.
;	
ST_VAL:		BGN#	0
			PSHA
			PSHX
			LDX#	0				; GET THE HUNDRED CHAR
			LDC		TEMP_CELL
			CMA#	0
			JEQ		@+3
			SBA#	'0'
			MUL#	100
			STA		TEMP_NUM
					
			LDA#	0				; GET THE TENTH CHAR
			LDX#	1
			LDC		TEMP_CELL
			CMA#	0
			JEQ		@+3
			SBA#	'0'
			MUL#	10
			ADA		TEMP_NUM
			STA		TEMP_NUM
					
			LDA#	0				; GET THE DECIMAL CHAR
			LDX#	2
			LDC		TEMP_CELL
			SBA#	'0'
			ADA		TEMP_NUM
			STA		TEMP_NUM
					
			LDA#	0				; CALCULATE THE OFFSET WHERE TO STORE THE CELL
			ADA		X_CURR_CELL
			SBA#	1
			STA		TEMP_INDEX
			LDA#	0
			ADA		Y_CURR_CELL
			SBA#	1
			MUL#	8
			ADA		TEMP_INDEX
			STA		TEMP_INDEX
			
			LDX		TEMP_INDEX
			LDA		TEMP_NUM		; TEMP_NUM HAS THE NUMERIC VALUE ENTERED IN DECIMAL
			
			LDA		OP				; LOAD THE OPERATION TO BE PERFORMED
			CMA#	PLUS			; COMPARE OPERAND WITH THE OPEARTION TO BE PERFORMED
			JEQ		ADD_			;
			CMA#	MINUS
			JEQ		SUB_
			CMA#	MULT
			JEQ		MUL_
			CMA#	DIVIDE
			JEQ		DIV_
			JMP		NEW_DATA_			

SUB_:		LDA&	CELL_ARRAY		; LOAD THE VALUE FROM THE ARRAY
			CMA#	999				; COMPARE MAXIMUNS
			JGT		DONE_ST			;
			CMA		MAX_NEG			;
			JLT		DONE_ST			; IN CASE OF 
			SBA		TEMP_NUM		; PERFORM OPERATION
			STA&	CELL_ARRAY
			JMP		DONE_ST			
ADD_:		LDA&	CELL_ARRAY		; SAME AS AVOBE BUT WITH DIFFERENT OPERAND
			CMA#	999				;
			JGT		DONE_ST			;
			CMA		MAX_NEG
			JLT		DONE_ST
			ADA		TEMP_NUM
			STA&	CELL_ARRAY
			JMP		DONE_ST			
MUL_:		LDA&	CELL_ARRAY		; SAME AS AVOBE BUT WITH DIFFERENT OPERAND
			CMA#	999				;
			JGT		DONE_ST			;
			CMA		MAX_NEG
			JLT		DONE_ST
			MUL		TEMP_NUM
			STA&	CELL_ARRAY
			JMP		DONE_ST			
DIV_:		LDA&	CELL_ARRAY		; SAME AS AVOBE BUT WITH DIFFERENT OPERAND
			CMA#	999				;
			JGT		DONE_ST			;
			CMA		MAX_NEG
			JLT		DONE_ST
			DIV		TEMP_NUM
			STA&	CELL_ARRAY
			JMP		DONE_ST			
NEW_DATA_:	LDA		TEMP_NUM		; SAME AS AVOBE BUT WITH DIFFERENT OPERAND
			STA&	CELL_ARRAY		;
			JMP		DONE_ST
			
DONE_ST:	LDA&	CELL_ARRAY

			POPX
			POPA
			FIN#	0
			RTN


;	SHOW_IN_VALUE
;
;	//	THIS FUNCTION DISPLAYS THE VALUE THAT IS JUST ENTED IN THE
;	//	BOTTOM LAST CORNER FOR INPUT VALUES.
;	
SHOW_IN_VALUE:
			BGN#	0
			PSHA
			PSHX				; SAVE INITIAL VALUES
			
			LDX#	0			; LOAD TEMPORARY
			LDC		TEMP_CELL
			OUTB	$311		; OUTPUT THE VALUE
			LDX#	1
			LDC		TEMP_CELL	; LOAD NEXT CHAR
			OUTB	$312		; OUTPUT VALUE
			LDX#	2
			LDC		TEMP_CELL	; LOAD NEXT CHAR
			OUTB	$313		; OUTPUT VALUE
			
			POPX				; RESTORE INITIAL VALUES
			POPA
			FIN#	0
			RTN


;	NEW_VALUE
;
;	//	THIS FUNCTION OUTPUTS THE BOTTOM NEW VALUE MESSAGE
;	// 
;
NEW_VALUE:
			BGN#	0
			PSHA				; SAVE INITIAL VALUES
			PSHX
			
			LDA		OP			; LOAD THE OPERAND
			CMA#	NEW_DATA	;
			JEQ		N_MSG
			JMP		D_NV
					
N_MSG:		LDX#	0			; LOAD THE NEW_VALUE STRING INTO SCREEN
			CMX#	ND_STRL		;
			JGE		@ + 5		;
			LDC 	ND_STR		; 
			OUTB+	CRT_OPER	; DISPLAY IT WITH RESPECT TO THE POSITION
			ADX#	1			; OF THE CRT
			JMP		@ - 5
			
D_NV:		POPX
			POPA
			FIN#	0
			RTN
			
			
;	CRL_BOTTOM
;
;	//	THIS FUNCTION CLEARS THE BOTTOM CHARACTERS AFTER AN OPERATION
;	//	HAS BEEN DONE. TO DO THAT IT JUST LOADS THE LAST LINE OF THE 
;	//	SCREEN BUFFER ORIGINALLY USED TO DISPLAY THE MAIN SCREEN
; 			
CRL_BOTTOM:
			BGN#	0
			PSHA				; SAVE INITIAL VALUES
			PSHX				;
			
			LDX#	0
			CMX#	COLNL		; START X = 0
			JGE		@ + 5		; DONE LOOP
			LDC 	COL_N		; LOAD CHARACTHER
			OUTB+	$2EE		; OUTPUT CHARACTHER
			ADX#	1			; MOVE TO THE NEXT SPACE
			JMP		@ - 5		; LOOP BACK AGAIN
			
			POPX				; RESTORE INITIAL VALUES
			POPA				;
			FIN#	0
			RTN


       