;**************************************************************************
;
; FILE:		P5SUB1.CSP
;
; DESCRIPTION:	PROJECT 5 SUBRUTINES 1
;
; AUTHOR:	R. JAVIER VEGA
;
;**************************************************************************


;	Functions start at $A00 address

		.EQU	@,		$A00

		JMP	MOV_CELL			; $A00 = MOVE_CELL
		JMP	SET_CELL			; $A01 = SET_CELL
		JMP	BEEP_MSG			; $A02 = BEEP_MSG
		JMP	CLR_BELL			; $A03 = CLEAR_BELL
		JMP	SW_CURTN			; $A04 = SHOW_CURR_CELL
		JMP	SW_VALUE			; $A05 = SHOW_CELL_VAL
		JMP	UPD_TOTS			; $A06 = UPDATE_TOTS


;		// I/O PORTS CONSTANTS
		.EQU	X_POS,		$314
		.EQU	Y_POS,		$315
		.EQU	CRT_CTRL,	$316
		.EQU	CRT_DATA,	$317
		.EQU	KBD_STAT,	$000
		.EQU	KBD_DATA,	$001

;		// PROGRAM CONSTANTS 
		.EQU	ROWS,		9
		.EQU	COLS,		8
		.EQU	TOT_CELLS,	ROWS * COLS

		.EQU	ZERO,		$000

		.EQU	MAX_R,		8				; MAX RIGHT MOST CELL VALUE
		.EQU	MAX_B,		9				; MAX BOTTOM MOST CELL VALUE
		.EQU	BELL_BEEP,	$07				; BELL CONSTANT FOR IO



;	// FUNCTION: MOVE_CELL ( X, Y, X_CURRENT, Y_CURRENT )
;
;	//	THIS FUNCTION MOVES THE CURRENT CELL X SPACES TO THE RIGHT 
;	//	AND Y SPACES UP. NEGATIVE VALUES ARE LEFT AND DOWN MOVES. 
;	//	THIS FUNCTION TAKES AS PARAMETERS THE CURRENT POSSITION OF
;	//	THE CURSOR AND THEN IT CALCULATES THE NEXT MOVEMENT DEPENDING
;	//	ON THE PARAMETERS PASSED TO THE FUNCTION.
;
;
;	//	LOCAL VARS
		.EQU	X_MOVES, 0
		.EQU	Y_MOVES, 1
		.EQU	NUM_LOCALS, 2

;	//	PARAMETERS
		.EQU	Y_CURR, NUM_LOCALS + 2
		.EQU	X_CURR, NUM_LOCALS + 3
		.EQU	Y_MOVE,	NUM_LOCALS + 4
		.EQU	X_MOVE, NUM_LOCALS + 5

MOV_CELL:	BGN#	NUM_LOCALS
			PSHA
			PSHX
			
			JSR		CLR_BELL			; CLEAR SCREEN IN CASE OF BEING BEEP

			LDA*	!X_CURR				; MOVE THE CURSOR IN THE X PLANE
			ADA		!X_MOVE				;
			CMA#	MAX_R				; CHECK FOR BOUNDRIES ? ZERO
			JGT		BEEP				; PROMPT ERROR BEEP
			CMA#	ZERO				; 
			JLE		BEEP				;
			STA*	!X_CURR				; UNDO CALCULATION
			STA		!X_MOVES			;

			LDA*	!Y_CURR				; PROCESS Y PLANE IN SAME WAY
			ADA		!Y_MOVE				;
			CMA#	MAX_B				; CHECK BOUNDRIES
			JGT		BEEP				;
			CMA#	ZERO				;
			JLE		BEEP				;
			STA*	!Y_CURR				;
			STA		!Y_MOVES			;

			PSH		!X_MOVES			; IF SUCCESSFULL 
			PSH		!Y_MOVES			; SET THE POSSITION OF THE CELL
			JSR		SET_CELL			; WITH THE NEW VALUES 
			ADS#	2
			JMP		@ + 2
BEEP:		JSR		BEEP_MSG			; IN CASE OF ERROR
            POPX
			POPA
			FIN#	NUM_LOCALS
			RTN
;
;







;	// FUNCTION: SET_CELL POSSITION ( INT X, Y ) 
;
;	//	SETS THE POSSITION OF THE CURSOR ACCORDING THE
;	//	SPECIFIED CELL ( X, Y ) VALUE PAIR. THIS FUNCTION
;	//	ALSO UPDATES THE INDEX COUNTER FOR POSSITION IN STAT
;	//	BAR SCREEN.
;	//	THIS FUNCTION IS MAINLY USED BY MOV_CELL.
;
;	// FUNCTION CONSTANTS
		.EQU	X_SPACED,		4		; SEPARATION BETWEEN CELLS IN X SPACE
		.EQU	Y_SPACED,		1		; "				"		"	  Y SPACE
		.EQU	X_START,		2		; INITIAL X POSITION FROM BORDER
		.EQU	Y_START,		2		; INITIAL Y POSITION FROM RIGHT TOP BORDER
		.EQU	ROWS_MAP,		$2E1	; ROW CRT MAP FOR DISPLAY
		.EQU	COLS_MAP,		$2D7	; COLUMNS CRT MAP FOR DISPLAY INDEX OF CELL

;	// PARAMETERS AND LOCAL VARS
		.EQU	NUM_LOC1,		0
		.EQU	Y_CELL_POS,		NUM_LOC1 + 2
		.EQU	X_CELL_POS,		NUM_LOC1 + 3

SET_CELL:	BGN#	NUM_LOC1
			LDA#	X_SPACED			;	// SET SPACES
			MUL		!X_CELL_POS
			ADA#	X_START
			OUTB	X_POS
			LDA#	Y_SPACED
			MUL		!Y_CELL_POS
			ADA#	Y_START
			OUTB	Y_POS
			LDA		!X_CELL_POS			;	// UPDATE RECORD X CELL POSSITION
			ADA#	'0'
			OUTB	ROWS_MAP
			LDA		!Y_CELL_POS			;	// UPDATE RECORD Y CELL POSSITION
			ADA#	'0'
			OUTB	COLS_MAP
			FIN#	NUM_LOC1
			RTN
;
;			




			
			
;	// BEEP_MSG	
;	//	THIS FUNCTION PRINTS OUT A BEEP MESSAGE AND 
;	//	ALSO PRINTS ON THE SCREEN A BELL STRING;

BEEP_MSG:	BGN#	0

			LDA#	'B'					; LOAD CHAR
			OUTB	$126				; PUT CHAR
			LDA#	'E'
			OUTB	$127
			LDA#	'L'
			OUTB	$128
			LDA#	'L'
			OUTB	$129

			LDA#	BELL_BEEP			; LOAD BEEP CHAR
			OUTB	CRT_DATA			; OUTPUT BEEP CHAR
				
			FIN#	0
			RTN


;	// CRL_BELL
;	//	THIS FUNCTION CLEARS THE SCREEN FROM THE BEEL
;	//	MESSAGE PRINTED WHEN AN ERROR HAS OCCURRED.
;	//

CLR_BELL:	BGN#	0
			LDA#	' '			; LOAD EMPTY CHAR
			OUTB	$126		; OUTPUT CHARS
			OUTB	$127
			OUTB	$128
			OUTB	$129
			FIN#	0
			RTN






;	// FUCTION: SW_CURTN
;	//	SHOW CURRENT CELL
;	//	THIS FUNCTION DISPLAYS THE VALUE JUST ENTERED OF A CELL IN THE 
;	//	VALUE BOX. THE PARAMETER PASSED IN THE STACK IS JUST A 
;	//	WORD THAT CONTAINS THE CHARCTERS TO BE DISPLAYED.
;	//
;

.EQU	SHOW_CELL,	2			;	PARAM THE WORD TO BE SHOWN

SW_CURTN:
			BGN#	0
			PSHA
			PSHX
			LDX#	0
			LDC		!SHOW_CELL		; LOAD THE CHARACTER 
			OUTB	$2EB			; OUTPUT THE CHAR
			LDX#	1				; GO NEXT CHAR
			LDC		!SHOW_CELL		; SAME FOR NEXT TWO!
			OUTB	$2EC
			LDX#	2
			LDC		!SHOW_CELL
			OUTB	$2ED
			POPX
			POPA
			FIN#	0
			RTN
;
;






;	// FUNCTION SW_VALUE : SHOW_CELL_VALUE
;
;	//	THIS FUNCTION DISPLAYS THE CONTENT OF ANY CELL INTO THE
;	//	VALUE BOX FOR BROWSING AVILITIES IN THE MATRIX CELL.
;	//	THE FUNCTION FIRST READS FROM THE SCREEN MAP THE ADDRES
;	//	THAT CONTAINS THE CHARACTERS AND THEN IT COPIES ONE BY
;	//	ONE DISPLAYING THEN IN THE VALUE BOX.
;	//

.EQU	TEMP_SCV,		0
.EQU	NUMLOC_SCV,		1

.EQU	X_CURR_SCV,	NUMLOC_SCV + 3
.EQU	Y_CURR_SCV,	NUMLOC_SCV + 2

;	PARAMS CALL ( X_CURR_CELL, Y_CURR_CELL_ )

SW_VALUE:	BGN#	NUMLOC_SCV
			PSHA
			PSHX
					
			LDA#	4				; CALCULATE INDEX OF POSSITION
			MUL		!X_CURR_SCV		;
			ADA#	$25				;
			STA		!TEMP_SCV		; X POSSITION
			
			LDA#	38				; CALC Y POSSITION
			MUL		!Y_CURR_SCV		;
			ADA		!TEMP_SCV		;
			STA		!TEMP_SCV		; STORE INDEX OF POSSITION

			LDX		!TEMP_SCV		; READ EACH CHAR AND OUTPUT ITS VALUE
			SBX#	1				;
			INB+	$100			;
			OUTB	$2EA			;

			LDX		!TEMP_SCV		; READ EACH CHAR AND OUTPUT ITS VALUE
			INB+	$100			;
			OUTB	$2EB			;

			LDX		!TEMP_SCV		; READ EACH CHAR AND OUTPUT ITS VALUE
			ADX#	1				;
			INB+	$100			;
			OUTB	$2EC			;

			LDX		!TEMP_SCV		; READ EACH CHAR AND OUTPUT ITS VALUE	
			ADX#	2				;
			INB+	$100			;
			OUTB	$2ED			;

			POPX
			POPA
			FIN#	NUMLOC_SCV
			RTN
;
;













;	// FUNCTION UPDATE_TOTS
;	//	THIS FUNCTION UPDATES THE TOTAL LIST OF THE CELL
;	//	ARRAY AND DISPLAY THE PROPER VALUES ( ***, -, + ).
;	//	DEPENDING THE TOTAL CALCULATED.
;	//	THIS FUNCTION FIRST CALCULATES THE TOTAL TO BE DISPLAYED AND 
;	//	THEN IT CALCULATED THE INDEX POSSITION IN THE CRT BUFFER
;	//	TO FINALLY CONVERT THE NUMBERS INTO CHARACTERS AND DISPLAY 
;	//	THEM TO THE SCREEN.
;

;	//	LOCAL VARIABLE DEFINITIONS
;
.EQU	TEMP,				0
.EQU	TEMP_INDEX,			1
.EQU	TEMP_NUM,			2
.EQU	NEGATIVE,			3
.EQU	MAX_NEGATIVE,		4
.EQU	DISPLAY_INDEX,		5
.EQU	CELL_VALUE,			6
.EQU	NUM_LOCALS_UPDATE,	7



;	PARAMS CALL ( X_CURR_CELL, Y_CURR_CELL_ CELL_ARRAY )
;
.EQU	X_CURR_CELL, NUM_LOCALS_UPDATE + 4
.EQU	Y_CURR_CELL, NUM_LOCALS_UPDATE + 3
.EQU	CELL_ARRAY,	 NUM_LOCALS_UPDATE + 2


UPD_TOTS:
			BGN#	NUM_LOCALS_UPDATE
			PSHA						; SAVE REGISTERS
			PSHX

			PSHA						; CHECK IF NUMBER IS NEGATIVE
			LDA#	999
			COMA
			ADA#	1
			STA		!MAX_NEGATIVE		; MAX NEGATIVE VALUE
			POPA
											
			LDA		!Y_CURR_CELL		; CALCULATE THE TOTAL OF THE CURRENT ROW
			SBA#	1
			MUL#	8
			STA		!TEMP_INDEX
			LDX		!TEMP_INDEX
			ADA#	8
			STA		!TEMP
			LDA#	0
CHECK:		CMX		!TEMP
			JGE		DONE_ROWS
	
			STA		!CELL_VALUE			; TEMP SAVE REGISTER

			LDA&	!CELL_ARRAY			; IF ANY VALUE IS OVER BOUNDRY
			CMA#	999
			JGT		SET_STARTS			; SET ROW TOTAL TO STARTS

			CMA		!MAX_NEGATIVE		; NEGATIVE BOUNDRY
			JLT		SET_STARTS

			LDA		!CELL_VALUE			; TEMP RESTORE REGISTER

			ADA&	!CELL_ARRAY			; IF NOT CONTINUE CALCULATE ROWS
			ADX#	1
			JMP		CHECK
DONE_ROWS:								; ACC = TOTAL OF ROWS IN Y CURRENT CELL
			CMA#	999
			JGT		SET_STARTS			; CHECK IF THE TOTAL ADDED IS OUT BOUNDRIES

			CMA		!MAX_NEGATIVE		; NEGATIVE CHECK
			JLT		SET_STARTS

			JMP		SHOW_ROW_TOT		; ELSE DISPLAY THE TOTAL
			
; // THIS CODE SETS THE CHARS TO STARTS 
SET_STARTS:	PSHA
			LDA		!Y_CURR_CELL
			SBA#	1
			MUL#	38
			TAX
			POPA
			LDA#	' '
			OUTB+	$16E
			LDA#	'*'
			OUTB+	$171
			OUTB+	$170
			OUTB+	$16F
			JMP		CALCULATE_COLS

; // ELSE SHOW THE TOTAL ROW
SHOW_ROW_TOT:
;CHECK: IN CASE THE TOTAL IS NEGATIVE
			PSHA
			LDA#	0
			STA		!NEGATIVE	; SET NEGATIVE FLAG ON
			POPA

			CMA#	0			; MAKE THE JUMP IF NEGATIE ELSE ASSUME POSSITIVE
			JLT	IS_NEG			;
			JMP	POS				;

; // IF THE NUMBER IS NEGATIVE, SET FLAG TO DISPLAY NEG SYMBOL AND TREAT 
; // NUMBER AS POSSITIVE FOR DISPLAY
IS_NEG:		COMA
			ADA#	1			; CONVERT VALUE TO POSITIVE FOR DISPLAY
			PSHA
			LDA#	1
			STA		!NEGATIVE	; SET TEMP IDEX TO 1 ( INDICATES DISPLAY - SIMBOL )
			POPA						
								; ACCUMULATOR HAS THE VALUE TO BE DISPLAYED ON SCREEN 
								; AS DECIMAL NUMBER AT THIS POINT
POS:
								; SET THE INDEX TO DISPLAY THE PROPER IO PORT
			PSHA
			LDA		!Y_CURR_CELL
			SBA#	1
			MUL#	38
			TAX
			STX		!DISPLAY_INDEX
			POPA

								; COMBERT NUMBER INTO CHARACTER DIGITS
			PSHA				; CONVERT FIRST DIGIT TO DECIMAL VALUE CHAR
			MOD#	100
			MOD#	10
			STA		!TEMP_NUM			
			ADA#	'0'	
			LDX		!DISPLAY_INDEX
			OUTB+	$171
			LDX#	2
			STC		!CELL_VALUE		; STORE CHAR INTO CELL LAST POSSITION
			POPA
			
			SBA		!TEMP_NUM		; SUBS FROM NUMBER PREVIOUS DISPLAYED ONE
			
			CMA#	100				; PROCESS NEXT NUMBER
			JLT		NEXT_NUM		;
			PSHA					;
			MOD#	100				;
			CMA#	0				;
			JGT		POPN_NUM		;
			LDA#	'0'				;
			LDX		!DISPLAY_INDEX	;
			OUTB+	$170			;
			LDX#	1				;
			STC		!CELL_VALUE		;
			POPA					;
			JMP		LAST_NUM		; IF DONE PROCESS NEXT NUMBER
			
POPN_NUM:	POPA
NEXT_NUM:	PSHA
			MOD#	100				; IN CASE THE NUMBER DOES NOT HAVE MORE DIGITS
			DIV#	10				; LOAD THE BLANK CHARS AND BE DONE.
			ADA#	'0'				;
			CMA#	'0'				;
			JNE		@ + 2			;
			LDA#	' '				;
			LDX		!DISPLAY_INDEX	;	
			OUTB+	$170
			LDX#	1
			STC		!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
			
LAST_NUM:	PSHA					; PROCESS LAST DECIMAL VALUE INTO TEMP_CELL
			DIV#	100				; SAME STEPS AS PREVIOUS CHARS
			ADA#	'0'				;
			CMA#	'0'				;
			JNE		@ + 2			;
			LDA#	' '				;	
			LDX		!DISPLAY_INDEX
			OUTB+	$16F
			LDX#	0
			STC		!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA

; DISPLAY THE NEGATIVE SIMBOL IN CASE OF NEGATIVE NUMBER

									; DISPLAY THE SIGN - IF NECESSARY

			LDA#	' '
			LDX	!DISPLAY_INDEX
			OUTB+	$16E

			LDA	!NEGATIVE
			CMA#	0				; IF NEGATIVE PROCCEDDE TO SHOW SYMBOL 
			JEQ	DONE_ROW_TOTALS		; GO TO POPX

			LDX#	1				; CHECK WHERE TO PUT THE NEGATIVE SYMBOL
			LDC		!CELL_VALUE		;
			CMA#	' '				;
			JNE		@ + 5			;
			LDA#	'-'				;
			LDX		!DISPLAY_INDEX	;
			OUTB+	$170			;
			JMP		DONE_ROW_TOTALS	;
			
			LDX#	0				;
			LDC		!CELL_VALUE		;
			CMA#	' '				;
			JNE	@ + 5				;
			LDA#	'-'				;
			LDX	!DISPLAY_INDEX		;
			OUTB+	$16F			;
			JMP	DONE_ROW_TOTALS		;

			LDA#	'-'				; ELSE USE NEXT DEFAULT POSSITION
			LDX		!DISPLAY_INDEX	;
			OUTB+	$16E			;
DONE_ROW_TOTALS:					; ROW TOTALS DONE

CALCULATE_COLS:						; GET COLS TOTAL
			LDA		!X_CURR_CELL	; THIS CODE USES THE SAME LOGIC THAN THE PREVIOUS
			SBA#	1				; BUT WITH DIFFERENT INDICES AND VALUES
			STA		!TEMP_INDEX		;
			LDX		!TEMP_INDEX		;
			ADA#	64				;
			STA		!TEMP			;
			LDA#	0				;
CCHECK:		CMX		!TEMP			;
			JGT		CDONE			;

	
			STA		!CELL_VALUE		; TEMP SAVE REGISTER

			LDA&	!CELL_ARRAY		;
			CMA#	999				;
			JGT		CSET_STARTS		; CHECK FOR BOUNDRIES

			CMA		!MAX_NEGATIVE	; NEGATIVE FLAG SET
			JLT		CSET_STARTS		;

			LDA		!CELL_VALUE		; TEMP RESTORE REGISTER

			ADA&	!CELL_ARRAY		; CONTINUE ADDING THE VALUES
			ADX#	8				;
			JMP		CCHECK			; LOOP BACK

CDONE:								; COLUMNS ADDING TOTAL DONE
			CMA#	999				; CHECK BOUNDRIS FOR PRINTING STARS
			JGT		CSET_STARTS		;

			CMA		!MAX_NEGATIVE	;
			JLT		CSET_STARTS		;

			JMP		SHOW_COL_TOT	; DISPLAY THE TOTAL 

CSET_STARTS:						; OUTPUT STARTS
			PSHA
			LDA		!X_CURR_CELL	;
			MUL#	4				;
			ADA#	2				;
			TAX						; LOAD INDEX FOR POSSITION OF OUTPUT
			POPA					;
			LDA#	'*'				; START DISPLAYING STARTS
			OUTB+	$2A1
			OUTB+	$2A0
			OUTB+	$29F
			LDA#	' '
			OUTB+	$29E
			JMP		FINAL_TOTAL		; DONE STARS

		
SHOW_COL_TOT:		
			PSHA					; CHECK: IN CASE THE TOTAL IS NEGATIVE
			LDA#	0
			STA	!NEGATIVE
			POPA

			CMA#	0
			JLT		COL_TOT_NEGATIVE	; IF NEGATIVE
			JMP		COL_TOT_POSITIVE	; ELSE ASSUME POSSITIVE

COL_TOT_NEGATIVE:	
			COMA
			ADA#	1			; CONVERT VALUE TO POSITIVE FOR DISPLAY
			PSHA
			LDA#	1
			STA	!NEGATIVE		; SET TEMP IDEX TO 1 ( INDICATES DISPLAY - SIMBOL )
			POPA						
								
								; ACCUMULATOR HAS THE VALUE TO BE DISPLAYED ON SCREEN 
								; AS DECIMAL NUMBER AT THIS POINT

COL_TOT_POSITIVE:
			STA	!CELL_VALUE
								; SET THE INDEX TO DISPLAY THE PROPER IO PORT
			PSHA
			LDA		!X_CURR_CELL
			MUL#	4
			ADA#	2
			TAX
			STX		!DISPLAY_INDEX			
			POPA

			; COMBERT NUMBER INTO CHARACTER DIGITS
			; SAME LOGIN AS IN ROW TOTAL
			PSHA
			MOD#	100
			MOD#	10
			STA		!TEMP_NUM			
			ADA#	'0'	
			LDX	!DISPLAY_INDEX
			OUTB+	$2A1
			LDX#	2
			STC	!CELL_VALUE
			POPA
			
			SBA		!TEMP_NUM
			
			CMA#	100
			JLT		CNEXT_NUM
			PSHA
			MOD#	100
			CMA#	0
			JGT		CPOPN_NUM
			LDA#	'0'
			LDX	!DISPLAY_INDEX
			OUTB+	$2A0
			LDX#	1
			STC	!CELL_VALUE
			POPA
			JMP		CLAST_NUM
			
CPOPN_NUM:	POPA
CNEXT_NUM:	PSHA
			MOD#	100
			DIV#	10
			ADA#	'0'	
			CMA#	'0'
			JNE		@ + 2
			LDA#	' '			
			LDX	!DISPLAY_INDEX
			OUTB+	$2A0
			LDX#	1
			STC	!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
			
CLAST_NUM:	PSHA
			DIV#	100
			ADA#	'0'
			CMA#	'0'
			JNE		@ + 2	
			LDA#	' '
			LDX	!DISPLAY_INDEX
			OUTB+	$29F
			LDX#	0
			STC	!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
									
			LDA#	' '				; DISPLAY THE NEGATIVE SIMBOL IN CASE OF NEGATIVE NUMBER
			LDX	!DISPLAY_INDEX
			OUTB+	$29E

			LDA		!NEGATIVE
			CMA#	0				; IF NEGATIVE PROCCEDDE TO SHOW SYMBOL 
			JEQ		DONE_COL_TOTALS	; GO TO POPX

			LDX#	1
			LDC		!CELL_VALUE
			CMA#	' '
			JNE	@ + 5
			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$2A0
			JMP		DONE_COL_TOTALS
			
			LDX#	0
			LDC		!CELL_VALUE
			CMA#	' '
			JNE	@ + 5
			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$29F
			JMP		DONE_COL_TOTALS

			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$29E
DONE_COL_TOTALS:					; ROW TOTALS DONE
;	// END COLUMN TOTALS CALCULATION AND DISPLAY

;	// SHOW ROWS AND COLS TOTALS SUM
FINAL_TOTAL:
			; USE THE INDEX CALCULATED FROM THE PREVIUOS
			; COL CALCULATION
			LDA#	0
			LDX#	0
TOT_LOOP:	CMX#	TOT_CELLS
			JGE		TOT_LOOP_DONE
	
			STA	!CELL_VALUE			; TEMP SAVE REGISTER

			LDA&	!CELL_ARRAY
			CMA#	999
			JGT		TSET_STARTS

			CMA		!MAX_NEGATIVE
			JLT		TSET_STARTS

			LDA		!CELL_VALUE		; TEMP RESTORE REGISTER

			ADA&	!CELL_ARRAY
			ADX#	1
			JMP		TOT_LOOP
			
TOT_LOOP_DONE:
			STX		!DISPLAY_INDEX

			CMA#	999
			JGT		TSET_STARTS

			CMA		!MAX_NEGATIVE
			JLT		TSET_STARTS

			JMP		SHOW_TOT_TOT
			
TSET_STARTS:
			LDA#	' '
			OUTB+	$27C
			LDA#	'*'
			OUTB+	$27F
			OUTB+	$27E
			OUTB+	$27D
			JMP		DONE_TOTALS
SHOW_TOT_TOT:		
;CHECK: IN CASE THE TOTAL IS NEGATIVE
			PSHA
			LDA#	0
			STA	!NEGATIVE
			POPA

			CMA#	0
			JLT	NEGATIVE_TOTAL
			JMP	POSITIVE_TOTAL
NEGATIVE_TOTAL:		COMA
			ADA#	1			; CONVERT VALUE TO POSITIVE FOR DISPLAY
			PSHA
			LDA#	1
			STA	!NEGATIVE		; SET TEMP IDEX TO 1 ( INDICATES DISPLAY - SIMBOL )
			POPA						
								; ACCUMULATOR HAS THE VALUE TO BE DISPLAYED ON SCREEN 
								; AS DECIMAL NUMBER AT THIS POINT
POSITIVE_TOTAL:
			PSHA
			MOD#	100
			MOD#	10
			STA		!TEMP_NUM			
			ADA#	'0'	
			LDX	!DISPLAY_INDEX
			OUTB+	$27F
			LDX#	2
			STC	!CELL_VALUE
			POPA
			
			SBA		!TEMP_NUM
			
			CMA#	100
			JLT		TNEXT_NUM
			PSHA
			MOD#	100
			CMA#	0
			JGT		TPOPN_NUM
			LDA#	'0'
			LDX	!DISPLAY_INDEX
			OUTB+	$27E
			LDX#	1
			STC		!CELL_VALUE
			POPA
			JMP		TLAST_NUM
			
TPOPN_NUM:	POPA
TNEXT_NUM:	PSHA
			MOD#	100
			DIV#	10
			ADA#	'0'	
			CMA#	'0'
			JNE		@ + 2
			LDA#	' '		
			LDX		!DISPLAY_INDEX
			OUTB+	$27E
			LDX#	1
			STC		!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
			
TLAST_NUM:	PSHA
			DIV#	100
			ADA#	'0'
			CMA#	'0'
			JNE		@ + 2	
			LDA#	' '
			LDX		!DISPLAY_INDEX
			OUTB+	$27D
			LDX#	0
			STC		!CELL_VALUE
			SBA#	'0'
			STA		!TEMP_NUM		; TEMP NUMBER HAS THE NUMBER WITH OUT THE LAST DIGIT
			POPA
;	// TOTALS DISPLAY
			
; DISPLAY THE NEGATIVE SIMBOL IN CASE OF NEGATIVE NUMBER
			; DISPLAY THE SIGN - IF NECESSARY
			LDA#	' '
			LDX	!DISPLAY_INDEX
			OUTB+	$27C

			LDA		!NEGATIVE
			CMA#	0			; IF NEGATIVE PROCCEDDE TO SHOW SYMBOL 
			JEQ		DONE_TOTALS	; GO TO POPX

			LDX#	1
			LDC		!CELL_VALUE
			CMA#	' '
			JNE	@ + 5
			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$27E
			JMP		DONE_TOTALS
			
			LDX#	0
			LDC		!CELL_VALUE
			CMA#	' '
			JNE	@ + 5
			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$27D
			JMP		DONE_TOTALS

			LDA#	'-'
			LDX		!DISPLAY_INDEX
			OUTB+	$27C
DONE_TOTALS:
			POPX
			POPA
			FIN#	NUM_LOCALS_UPDATE
			RTN
;
;


